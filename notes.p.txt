# personal practice notes only
*.p.txt

## How to think about the task (supervision style)

When you start, **do NOT write code immediately**.  
First make sure you can **describe everything in words**:  
what it means in the **real world** and what it means as a **programmer**.

---

## 1. Understand the input

### Real world
- What does one `FundingRequest` represent in reality?
in short: 
a request for money
with state and metadata

A FundingRequest represents one financial request for funding, 
created at a specific time, with a defined requested amount, 
that is later processed and evaluated by the system.

- Who creates it and why does it exist?
A FundingRequest is created by a requesting party 
that asks for financial resources. 
It exists to formally record the request so it can be reviewed, 
decided upon, and later reported or audited.

- What decision or process does it belong to?
A FundingRequest is the unit that moves through an approval process
and carries all information needed to make a funding decision.

### As a programmer

- What is a `FundingRequest` structurally?

  - What kind of thing is it in C#?  
    It is a record type that defines the structure of a data object by grouping
    related values (Id, Amount, Status, SubmissionDate) into one unit.

  - What does it contain?  
    A fixed set of named, typed fields.

  - Does it do anything, or does it only describe data?  
    It only describes data and contains no business logic.


- What does the `namespace` tell you?
  - Why is this type placed inside a namespace?
  To organize code and prevent name collisions.

  - How does this help organize code?
  By grouping related code and avoiding name collisions.
  
  - How do other files access this type?
    By importing its namespace, 
    so the compiler knows where the type is defined.
    
    With:
    using ReportingChallenge.src;
    FundingRequest request = new FundingRequest(...);

    Without:
    ReportingChallenge.src.FundingRequest request = new ReportingChallenge.src.FundingRequest(...);


- Why is this a `record` and not a class?
  - What is a `record` used for?
  To model structured data made up of related values.

  - What problem does it solve compared to a class?
  A record is used to represent data, not behavior, 
  while a class is typically
  used to model objects that contain behavior and operations.

  - Why is it a good fit for a funding request?
  A funding request represents data about a request, while actions like
  approving or rejecting it belong to separate logic.  


### Fields
- Which fields matter for this task?  
  - `Status`
    Represents the current decision state of the request and is used for grouping.

  - `Amount`
    Represents the requested amount of money and is used for budget checks.

  - `SubmissionDate`
    Represents the time when the funding request was submitted

  -> status, what
    amount, how much
    submissionDate, when

- Can any field be:
  - null?
    Only `Status` can be null, because it is a reference type (`string`), while
    `Id`, `Amount`, and `SubmissionDate` are value types.

    - A reference type stores a reference (address) to an object in memory.
    The reference can be `null`, meaning no object exists.
    - A value type stores the actual value directly.
    It must always contain a value and therefore cannot be null.

    Example (reference type):
    `string status = null;`  
    The variable does not contain text; it would only point to where the text
    is stored. `null` means there is no object.

    Example (value type):
    `int id = 0;`  
    The variable directly contains the number. There is no concept of a
    “missing int”, so `int id = null` is not allowed.

    Applied to this model:
    - `Status = null` → request exists, but its state is unknown
    - `Id`, `Amount`, `SubmissionDate` → always have a value

  - empty?
    - `Status = ""` → the request exists, but its state is unspecified or invalid
    - `Id`, `Amount`, and `SubmissionDate` cannot be empty, because value types
    do not have an “empty” state, only concrete values.

  - zero?
    `Id` and `Amount` can be zero because they are numeric value types.

    Example:
    `int id = 0;`  
    `decimal amount = 0m;`  
    Zero represents a valid numeric value, not a missing one.

    `SubmissionDate` cannot be zero.
    It is a `DateTime` value type and always
    represents a concrete point in time

    `Status` cannot be zero, because it is a string.
    `"0"` would be a string value, not the number zero.

  - negative?
    `Id` and `Amount` can technically be negative because they are numeric
    value types.  
    `SubmissionDate` cannot be negative, and `Status` cannot be negative
    because it is a string.
    
---

## 2. Define the output

### Grouping
- What exactly should `GroupByStatus` return?
- What does one key represent?
- What does one value (list) represent?
- Which keys do you *expect*?
  - `"Approved"`
  - `"Review"`
  - `"Rejected"`

### Budget warnings
- What is a budget warning *conceptually*?
- What information must it contain?
- What should one warning look like as a string?

Example:
Request Id=2: Amount 75000 exceeds limit 50000


---

## 3. Plan the steps (no code)

- How would you explain the full solution in **3–5 sentences** to another developer?
- Which operations are:
  - grouping?
  - filtering?
  - formatting?
- Where does LINQ *replace* manual loops?
- Which helper ideas exist conceptually?
  - checking limits
  - formatting messages

---

## 4. Think about edge cases

- What if the input list is empty?
- What if an unknown status appears?
- What if `Amount` is `0`?
- What if `Amount` is negative?
- Should anything be ignored, grouped, or warned about?

---

## 5. Read the tests as specification

- How many groups do the tests expect?
- How many warnings do they expect?
- Which values are asserted?
- Do you understand **why** each assertion exists?

---

## 6. Only then start coding

1. Implement `GroupByStatus` → run `dotnet test`
2. Implement `GetBudgetWarnings` → run `dotnet test`
3. Implement `GenerateReport` → check console output

---

## 7. Understand the surrounding code (context)

- What is the responsibility of `FundingCenterReporter`?
  - What kind of logic belongs there?
  - What kind of logic does *not* belong there?

- What is the role of `Program.cs`?
  - Why is logic not implemented there?
  - What does “orchestration” mean in this context?

- What is the role of the test project?
  - What behavior is specified by tests?
  - What is left intentionally unspecified?

---

## 8. Responsibility check (before coding)

Before writing code, verify:

- The data model (`FundingRequest`) contains no logic
- The reporter contains transformation and reporting logic
- The program only wires things together
- Tests define correctness, not implementation