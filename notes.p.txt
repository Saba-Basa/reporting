# personal practice notes only
*.p.txt

## How to think about the task (supervision style)

When you start, **do NOT write code immediately**.  
First make sure you can **describe everything in words**:  
what it means in the **real world** and what it means as a **programmer**.

---

## 1. Understand the input

### Real world
- What does one `FundingRequest` represent in reality?
in short: 
a request for money
with state and metadata

A FundingRequest represents one financial request for funding, 
created at a specific time, with a defined requested amount, 
that is later processed and evaluated by the system.

- Who creates it and why does it exist?
A FundingRequest is created by a requesting party 
that asks for financial resources. 
It exists to formally record the request so it can be reviewed, 
decided upon, and later reported or audited.

- What decision or process does it belong to?
A FundingRequest is the unit that moves through an approval process
and carries all information needed to make a funding decision.

### As a programmer

- What is a `FundingRequest` structurally?

  - What kind of thing is it in C#?  
    It is a record type that defines the structure of a data object by grouping
    related values (Id, Amount, Status, SubmissionDate) into one unit.

  - What does it contain?  
    A fixed set of named, typed fields.

  - Does it do anything, or does it only describe data?  
    It only describes data and contains no business logic.


- What does the `namespace` tell you?
  - Why is this type placed inside a namespace?
  To organize code and prevent name collisions.

  - How does this help organize code?
  By grouping related code and avoiding name collisions.
  
  - How do other files access this type?
    By importing its namespace, 
    so the compiler knows where the type is defined.
    
    With:
    using ReportingChallenge.src;
    FundingRequest request = new FundingRequest(...);

    Without:
    ReportingChallenge.src.FundingRequest request = new ReportingChallenge.src.FundingRequest(...);


- Why is this a `record` and not a class?
  - What is a `record` used for?
  To model structured data made up of related values.

  - What problem does it solve compared to a class?
  A record is used to represent data, not behavior, 
  while a class is typically
  used to model objects that contain behavior and operations.

  - Why is it a good fit for a funding request?
  A funding request represents data about a request, while actions like
  approving or rejecting it belong to separate logic.  


### Fields
- Which fields matter for this task?  
  - `Status`
    Represents the current decision state of the request and is used for grouping.

  - `Amount`
    Represents the requested amount of money and is used for budget checks.

  - `SubmissionDate`
    Represents the time when the funding request was submitted

  -> status, what
    amount, how much
    submissionDate, when

- Can any field be:
  - null?
    Only `Status` can be null, because it is a reference type (`string`), while
    `Id`, `Amount`, and `SubmissionDate` are value types.

    - A reference type stores a reference (address) to an object in memory.
    The reference can be `null`, meaning no object exists.
    - A value type stores the actual value directly.
    It must always contain a value and therefore cannot be null.

    Example (reference type):
    `string status = null;`  
    The variable does not contain text; it would only point to where the text
    is stored. `null` means there is no object.

    Example (value type):
    `int id = 0;`  
    The variable directly contains the number. There is no concept of a
    “missing int”, so `int id = null` is not allowed.

    Applied to this model:
    - `Status = null` → request exists, but its state is unknown
    - `Id`, `Amount`, `SubmissionDate` → always have a value

  - empty?
    - `Status = ""` → the request exists, but its state is unspecified or invalid
    - `Id`, `Amount`, and `SubmissionDate` cannot be empty, because value types
    do not have an “empty” state, only concrete values.

  - zero?
    `Id` and `Amount` can be zero because they are numeric value types.

    Example:
    `int id = 0;`  
    `decimal amount = 0m;`  
    Zero represents a valid numeric value, not a missing one.

    `SubmissionDate` cannot be zero.
    It is a `DateTime` value type and always
    represents a concrete point in time

    `Status` cannot be zero, because it is a string.
    `"0"` would be a string value, not the number zero.

  - negative?
    `Id` and `Amount` can technically be negative because they are numeric
    value types.  
    `SubmissionDate` cannot be negative, and `Status` cannot be negative
    because it is a string.

---

============================================================
QUESTIONS — FundingCenterReporter
============================================================

Context: FundingCenterReporter

- What is the responsibility of the FundingCenterReporter class?
  The responsibility of the FundingCenterReporter class is to 
  interpret funding request data and derive grouped 
  summaries and budget warnings from it.

- Why is this logic placed in a separate class and not in Program.cs?
  The logic is separated to keep Program.cs focused on 
  orchestration and to isolate reporting logic in its own class.

- Does this class store state, or does it only operate on provided data?
  The class is stateless and 
  performs computations only on the input data it receives.

------------------------------------------------------------
Grouping (GroupByStatus) — Reasoning Template
------------------------------------------------------------

Method:
Dictionary<string, List<FundingRequest>> GroupByStatus(
    IEnumerable<FundingRequest> requests
)

1. Purpose
- What responsibility does this method have in the reporting process?
The responsibility of this method is to organize funding requests into groups 
based on their approval status for reporting purposes.

- What question does it answer about the funding requests?
Which requests are approved, 
which are under review, and which are rejected?

2. Input → Output (Transformation)
- What is the input data?
an iterable sequence of funding requests.

- What information is produced as output?
a mapping that associates each status 
with the list of requests that have that status.
key   → status
value → list of requests with that status
"Approved"  → [req1, req2, req3]
"Review"    → [req4]
"Rejected"  → [req5]

- How is the input transformed into the output?
The input is transformed by examining each funding request 
and assigning it to a group based on its status.

- What does returning this value enable the caller to do?
It enables the caller to easily inspect, analyze, 
or report on funding requests per approval status.

3. Data Modeling
- Why is the result a Dictionary?
Because the result needs to represent an 
association between each status 
and the group of funding requests with that status.
This association is expressed using a key–value structure.

- Why is string used as the key type?
Because the approval status is represented as a string 
in the data model, 
and the grouping key must match that representation.

- Why is the value a List<FundingRequest> and not a single object?
Because each status can correspond to many funding requests, 
the value needs to be a collection rather than a single object.
Since dictionary keys must be unique, 
using a single object would either overwrite
previous requests or lose information.
"Approved" → req1 ....

- What does one key represent conceptually?
one key represents one approval state 
used to categorize funding requests.
"Approved" →

- What does one list (value) represent conceptually?
one list represents the group of funding requests belonging to a single approval category.
→ [req1, req2, req3]

4. Assumptions & Boundaries
- Which status values are expected to appear as keys?
"Approved", "Review", "Rejected"
but the actual keys are derived from the input data.

- Are these keys assumed in advance or derived from the input?
derived from the input
The dictionary groups requests by 
whatever status values actually appear in the input data, 
regardless of whether those statuses are predefined or expected.

- What should happen if an unknown status appears?
It should be grouped like any other status, 
resulting in a new key
with the corresponding funding requests as its value.

5. Edge Cases
- What should be returned if the input sequence is empty?
An empty dictionary
requests = [] -> {}

- Should empty groups ever appear?
grouping only creates groups
for statuses that actually occur in the input data.
at least one item belongs to it
requests = [Approved]→ { "Approved" → [req] }

- Is an unknown status an error or just another group?
It is not an error, because the method groups 
by whatever status values
appear in the input data

6. Responsibility Check
- Does this method only transform data, or does it make decisions?
The method only transforms data
- What would clearly not belong in this method?
Any business or validation logic.

------------------------------------------------------------
Budget warnings (GetBudgetWarnings)
------------------------------------------------------------

Method signature:
IEnumerable<string> GetBudgetWarnings(
    IEnumerable<FundingRequest> requests,
    decimal limit
)

1. Purpose
- Why does this component exist?
The method exists to identify and report budget violations.
- What problem does it solve?
It answers the problem: Which funding requests exceed a given budget limit.
- What responsibility does it have?
it deriving budget exceedance information 
from funding requests and 
expressing that information as warnings.

2. Input → Output

- What is the input?
A budget limit and one or more funding requests to compare against it.
- What is the output?
A sequence of zero or more strings.
If no funding request violates the budget limit, 
the sequence is empty.
If one or more requests violate the limit, 
each violation is represented by one string.
- What transformation happens in between?
Funding requests are checked against the budget limit, 
and violations are turned into warning messages.

3. Data Modeling

/*notes*/
What is the method responsible for producing or deciding?
A budget warning when a funding request exceeds the limit.

What is the smallest meaningful piece of output?
One warning message describing a single budget violation.

How many such outputs can exist?
Zero, one, or many.

How should one unit be represented?
A text message.

How should multiple units be returned or handled?
As a sequence of warning messages.

/* enumerable: a row of items that can be iterated over as a sequence */

- Why does this method return IEnumerable<string>?
The method can produce zero, one, or many warning messages, each represented as a string, and they are returned as a sequence.

- Why return strings instead of objects?
The warnings are meant to be 
human-readable report messages, 
and no further structured processing is required.

- What does one string represent conceptually?
One warning message describing a single budget violation.

- What is a budget warning in real-world terms?
It is a notification that a requested amount is higher 
than what is allowed by the budget.

4. Assumptions & Boundaries

- What condition causes a warning to be generated?
- What information must each warning include?
- Why is the budget limit a parameter and not hard-coded?
- What must this method not do?

5. Edge Cases

- What should happen if the input is empty?
- What should happen if no request exceeds the limit?
- Should the order of warnings matter?

6. Responsibility Check

- Does this method store state or only operate on data?
- Why does this logic belong here?
- What would be wrong to put here?



------------------------------------------------------------
High-level report (GenerateReport)
------------------------------------------------------------

Method signature:
void GenerateReport(IEnumerable<FundingRequest> requests)

...

------------------------------------------------------------
Final check
------------------------------------------------------------
...
---

## 3. Plan the steps (no code)

- How would you explain the full solution in **3–5 sentences** to another developer?
- Which operations are:
  - grouping?
  - filtering?
  - formatting?
- Where does LINQ *replace* manual loops?
- Which helper ideas exist conceptually?
  - checking limits
  - formatting messages

---

## 4. Think about edge cases

- What if the input list is empty?
- What if an unknown status appears?
- What if `Amount` is `0`?
- What if `Amount` is negative?
- Should anything be ignored, grouped, or warned about?

---

## 5. Read the tests as specification

- How many groups do the tests expect?
- How many warnings do they expect?
- Which values are asserted?
- Do you understand **why** each assertion exists?

---

## 6. Only then start coding

1. Implement `GroupByStatus` → run `dotnet test`
2. Implement `GetBudgetWarnings` → run `dotnet test`
3. Implement `GenerateReport` → check console output

---

## 7. Understand the surrounding code (context)

- What is the responsibility of `FundingCenterReporter`?
  - What kind of logic belongs there?
  - What kind of logic does *not* belong there?

- What is the role of `Program.cs`?
  - Why is logic not implemented there?
  - What does “orchestration” mean in this context?

- What is the role of the test project?
  - What behavior is specified by tests?
  - What is left intentionally unspecified?

---

## 8. Responsibility check (before coding)

Before writing code, verify:

- The data model (`FundingRequest`) contains no logic
- The reporter contains transformation and reporting logic
- The program only wires things together
- Tests define correctness, not implementation